local c = workspace.CurrentCamera
local player = game.Players.LocalPlayer
local userInput = game:GetService("UserInputService")
local rs = game:GetService("RunService")

local selected = false
local speed = 60
local lastUpdate = 0

local camera = Instance.new('Part', workspace)
camera.CanCollide = false
camera.Anchored = true
camera.Transparency = 1
camera.Position = player.Character.HumanoidRootPart.Position + Vector3.new(0,5,0)

function getNextMovement(deltaTime)
    local nextMove = Vector3.new()
    if userInput:IsKeyDown("A") or userInput:IsKeyDown("Left") then
        nextMove = nextMove + Vector3.new(-.5,0,0)
    end
    if userInput:IsKeyDown("D") or userInput:IsKeyDown("Right") then
        nextMove = nextMove + Vector3.new(.5,0,0)
    end
    if userInput:IsKeyDown("W") or userInput:IsKeyDown("Up") then
        nextMove = nextMove + Vector3.new(0,0,-.5)
    end
    if userInput:IsKeyDown("S") or userInput:IsKeyDown("Down") then
        nextMove = nextMove + Vector3.new(0,0,.5)
    end
    if userInput:IsKeyDown("E") then
        nextMove = nextMove + Vector3.new(0,.2,0)
    end
    if userInput:IsKeyDown("Q") then
        nextMove = nextMove + Vector3.new(0,-.2,0)
    end
    return CFrame.new( nextMove * (speed * deltaTime) )
end

function onSelected()
    local char = player.Character
    if char then
        local root = camera
        currentPos = root.Position
        selected = true
        lastUpdate = tick()
        c.CameraSubject = root
        player.Character.HumanoidRootPart.Anchored = true
        while selected do
            local delta = tick()-lastUpdate
            local look = (c.Focus.p-c.CoordinateFrame.p).unit
            local move = getNextMovement(delta)
            local pos = root.Position
            root.CFrame = CFrame.new(pos,pos+look) * move
            lastUpdate = tick()
            wait(0.01)
        end
        player.Character.HumanoidRootPart.Anchored = false
        c.CameraSubject = player.Character.Humanoid
        root.Velocity = Vector3.new()
    end
end

spawn(onSelected)

game:GetService("RunService").RenderStepped:Connect(function()
    game.workspace.FallenPartsDestroyHeight = 0/0
    game:GetService("Players").LocalPlayer.ReplicationFocus = game.Players.LocalPlayer.Character
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
	setsimulationradius(1000)
    sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 1000)
end)

sine = 0
vel = Vector3.new(-18,0,-18)

local Body = game.Players.LocalPlayer.Character.NoHead.Handle
local Hat = game.Players.LocalPlayer.Character.LowpolyTophat.Handle
local RightHand = game.Players.LocalPlayer.Character[game:GetObjects("rbxassetid://5891633061")[1].Name].Handle
local LeftHand = game.Players.LocalPlayer.Character[game:GetObjects("rbxassetid://5891632410")[1].Name].Handle
local Aura = game.Players.LocalPlayer.Character["Ink Aura Final forward"].Handle

Body.AccessoryWeld:Destroy()
Hat.AccessoryWeld:Destroy()
RightHand.AccessoryWeld:Destroy()
LeftHand.AccessoryWeld:Destroy()
Aura.AccessoryWeld:Destroy()

game:GetService("RunService").Stepped:Connect(function()
    Body.Velocity = vel
    Hat.Velocity = vel
    RightHand.Velocity = vel
    LeftHand.Velocity = vel
    Aura.Velocity = vel
end)

function GetClosest(h)
	local Lowest = {nil, nil}
	for _, Player in ipairs(game.Players:GetPlayers()) do
        if Player.Name ~= game.Players.LocalPlayer.Name then
            local Distance = Player:DistanceFromCharacter(h.Position)
            if Distance == 0 then continue end
            if Lowest[1] == nil or Lowest[2] == nil then
                Lowest[1] = Player
                Lowest[2] = Distance
                continue
            end
            if Distance < Lowest[2] then
                Lowest[1] = Player
                Lowest[2] = Distance
            end
        end
	end
	return Lowest[1]
end

local MaxDistance = 10000
local Part = Body 

game:GetService("RunService").Heartbeat:Connect(function()
    --local tPos = game.Players[tostring(GetClosest(Body))].Character:FindFirstChild("HumanoidRootPart").Position
    local R = Ray.new(Part.Position, Vector3.new(0,-1*MaxDistance,0))
    local PartFound, Pos = workspace:FindPartOnRay(R, game.Players.LocalPlayer.Character, false, true)
    local DistanceToGround = Part.Position.Y-Pos.Y
    sine += 1

    Body.CFrame = camera.CFrame --[[* CFrame.new(Vector3.new(0,0,0) ,Vector3.new(tPos.X,tPos.Y,tPos.Z))]] * CFrame.Angles(0,math.rad(180),0)
    Hat.CFrame = Body.CFrame * CFrame.new(0,0.95,0)
    RightHand.CFrame = Body.CFrame * CFrame.new(-1.5,-0.5-math.cos(sine/100)/5,1-math.cos(sine/100)/5) * CFrame.Angles(math.rad(-100)+math.cos(sine/100)/15,math.rad(-10)+math.cos(sine/100)/5,math.rad(180))
    LeftHand.CFrame = Body.CFrame * CFrame.new(1.5,-0.5-math.cos(sine/100)/5,1-math.cos(sine/100)/5) * CFrame.Angles(math.rad(-100)+math.cos(sine/100)/15,math.rad(10)-math.cos(sine/100)/5,math.rad(180))
    Aura.CFrame = CFrame.new(Body.CFrame.p) * CFrame.new(0,-DistanceToGround+1,0) * CFrame.Angles(0,math.rad(sine/10),0)
end)
